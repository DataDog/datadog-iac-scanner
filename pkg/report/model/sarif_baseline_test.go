package model

import (
	"context"
	"fmt"
	"strings"
	"testing"
	"time"

	"github.com/DataDog/datadog-iac-scanner/pkg/model"
	"github.com/stretchr/testify/require"
)

const (
	expectedToolName = "Datadog IaC Scanning"
	expectedToolURI  = "https://docs.datadoghq.com/security/code_security/iac_security/"
)

var (
	allowedToolTagPrefixes = [3]string{
		"DATADOG_EXECUTION_TIME_SECS:",
		"DATADOG_SCANNED_FILE_COUNT:",
		"DATADOG_DIFF_AWARE_ENABLED:",
	}

	expectedRuleProperties = map[string]bool{
		"tags":           true,
		"iac-frameworks": true,
	}

	allowedRuleTagPrefixes = []string{
		"DATADOG_RULE_TYPE:",
		"DATADOG_CATEGORY:",
		"KICS_RuleID:",
		"KICS_QUERY_ID:",
		"DATADOG_PLATFORM:",
		"DATADOG_PROVIDER:",
		"CWE:",
	}

	requiredRuleTagPrefixes = []string{
		"DATADOG_RULE_TYPE:",
		"DATADOG_CATEGORY:",
		"DATADOG_PLATFORM:",
		"DATADOG_PROVIDER:",
		"KICS_RuleID:",
	}

	allowedResultTagPrefixes = []string{
		"DATADOG_CATEGORY:",
		"IAC_RESOURCE_TYPE:",
		"IAC_RESOURCE_NAME:",
		"CWE:",
	}

	requiredResultTagPrefixes = []string{
		"DATADOG_CATEGORY:",
		"IAC_RESOURCE_TYPE:",
		"IAC_RESOURCE_NAME:",
	}
)

// TestSarifOutputValidation validates that the SARIF output generated by the code
// has the correct structure, properties, tags, and no duplicates.
func TestSarifOutputValidation(t *testing.T) {
	ctx := context.Background()

	// Create test query results with various scenarios
	queryResults := []model.QueryResult{
		{
			QueryName:     "Test Security Rule",
			QueryID:       "test-rule-id-123",
			Description:   "This is a test security rule description",
			QueryURI:      "https://docs.datadoghq.com/test-rule",
			Severity:      model.SeverityHigh,
			Category:      "Security",
			Platform:      "Terraform",
			CloudProvider: "AWS",
			CWE:           "78",
			Frameworks: []model.Framework{
				{
					Framework:        "cis-aws",
					FrameworkVersion: "1.4.0",
					Control:          "2.1.1",
					Requirement:      "Ensure CloudTrail is enabled",
				},
			},
			Files: []model.VulnerableFile{
				{
					FileName:       "main.tf",
					Line:           10,
					KeyActualValue: "security issue found",
					ResourceType:   "aws_s3_bucket",
					ResourceName:   "my-bucket",
					ResourceLocation: model.ResourceLocation{
						Start: model.ResourceLine{Line: 10, Col: 1},
						End:   model.ResourceLine{Line: 15, Col: 5},
					},
				},
			},
		},
		{
			QueryName:     "Test Best Practice Rule",
			QueryID:       "test-rule-id-456",
			Description:   "This is a test best practice rule",
			QueryURI:      "https://docs.datadoghq.com/test-rule-2",
			Severity:      model.SeverityMedium,
			Category:      "Best Practices",
			Platform:      "Dockerfile",
			CloudProvider: "",
			Files: []model.VulnerableFile{
				{
					FileName:       "Dockerfile",
					Line:           5,
					KeyActualValue: "best practice violation",
					ResourceType:   "RUN",
					ResourceName:   "install-packages",
					ResourceLocation: model.ResourceLocation{
						Start: model.ResourceLine{Line: 5, Col: 1},
						End:   model.ResourceLine{Line: 5, Col: 50},
					},
				},
			},
		},
	}

	// Generate SARIF report
	report := NewSarifReport()
	for i := range queryResults {
		report.BuildSarifIssue(ctx, &queryResults[i], model.SCIInfo{})
	}

	// Add tool tags
	now := time.Now()
	summary := &model.Summary{
		Times: model.Times{
			Start: now,
			End:   now.Add(10 * time.Second),
		},
		Counters: model.Counters{
			ScannedFiles: 10,
		},
	}
	err := report.AddTags(ctx, summary, &model.DiffAware{})
	require.NoError(t, err)

	// Cast to concrete type to access fields
	sarif := report.(*sarifReport)

	// Now validate the generated SARIF
	t.Run("Tool Properties Validation", func(t *testing.T) {
		// There is always exactly one run
		require.Len(t, sarif.Runs, 1)
		driver := sarif.Runs[0].Tool.Driver

		// Validate tool metadata
		require.Equal(t, expectedToolName, driver.ToolName)
		require.NotEmpty(t, driver.ToolVersion)
		require.Equal(t, expectedToolURI, driver.ToolURI)

		// Validate tool properties tags
		tags := driver.Properties.Tags
		require.NotEmpty(t, tags)

		// Check for duplicates
		tagSet := make(map[string]bool)
		for _, tag := range tags {
			require.False(t, tagSet[tag], "Duplicate tag found in tool properties: %s", tag)
			tagSet[tag] = true
		}

		hasToolTagPrefixes := make([]bool, len(allowedToolTagPrefixes))
		// Validate only allowed tool tags are present
		for _, tag := range tags {
			hasAllowedPrefix := false
			for idx, prefix := range allowedToolTagPrefixes {
				if strings.HasPrefix(tag, prefix) {
					hasToolTagPrefixes[idx] = true
					hasAllowedPrefix = true
					break
				}
			}
			require.True(t, hasAllowedPrefix, "Unexpected tag in tool properties: %s", tag)
		}

		// Validate required tags are present
		for idx, prefix := range allowedToolTagPrefixes {
			require.True(t, hasToolTagPrefixes[idx], fmt.Sprintf("Missing %s tag", prefix))
		}
	})

	t.Run("Rules Structure Validation", func(t *testing.T) {
		rules := sarif.Runs[0].Tool.Driver.Rules
		require.Len(t, rules, 2, "Should have 2 rules for 2 query results")

		for _, rule := range rules {
			// Validate required fields
			require.NotEmpty(t, rule.RuleID)
			require.NotEmpty(t, rule.RuleName)
			require.NotEmpty(t, rule.RuleShortDescription.Text)
			require.NotEmpty(t, rule.RuleFullDescription.Text)
			require.NotEmpty(t, rule.HelpURI)
			require.NotEmpty(t, rule.DefaultConfiguration.Level)

			// Validate only allowed properties exist
			for propKey := range rule.RuleProperties {
				require.True(t, expectedRuleProperties[propKey],
					"Unexpected property in rule %s: %s", rule.RuleID, propKey)
			}

			// Validate tags property exists
			require.Contains(t, rule.RuleProperties, "tags")
			require.Contains(t, rule.RuleProperties, "iac-frameworks")

			// Validate rule tags
			tags, ok := rule.RuleProperties["tags"].([]string)
			require.True(t, ok, "Rule tags should be []string")

			// Check for duplicates
			tagSet := make(map[string]bool)
			for _, tag := range tags {
				require.False(t, tagSet[tag], "Duplicate tag in rule %s: %s", rule.RuleID, tag)
				tagSet[tag] = true
			}

			// Validate only allowed tag prefixes
			for _, tag := range tags {
				hasAllowedPrefix := false
				for _, prefix := range allowedRuleTagPrefixes {
					if strings.HasPrefix(tag, prefix) {
						hasAllowedPrefix = true
						break
					}
				}
				require.True(t, hasAllowedPrefix, "Unexpected tag in rule %s: %s", rule.RuleID, tag)
			}

			// Validate required tags are present
			hasRuleTagPrefixes := make([]bool, len(requiredRuleTagPrefixes))

			for _, tag := range tags {
				if strings.HasPrefix(tag, "DATADOG_RULE_TYPE:") {
					require.Equal(t, "DATADOG_RULE_TYPE:IAC_SCANNING", tag)
				}
				if strings.HasPrefix(tag, "CWE:") {
					parts := strings.Split(tag, ":")
					require.Len(t, parts, 2)
					require.NotEmpty(t, parts[1])
				}
				for idx, prefix := range requiredRuleTagPrefixes {
					if strings.HasPrefix(tag, prefix) {
						hasRuleTagPrefixes[idx] = true
						break
					}
				}
			}

			for idx, prefix := range requiredRuleTagPrefixes {
				require.True(t, hasRuleTagPrefixes[idx], fmt.Sprintf("Rule %s missing %s tag", rule.RuleID, prefix))
			}
		}
	})

	t.Run("Results Structure Validation", func(t *testing.T) {
		results := sarif.Runs[0].Results
		require.Len(t, results, 2, "Should have 2 results for 2 vulnerable files")

		for _, result := range results {
			// Validate required fields
			require.NotEmpty(t, result.ResultRuleID)
			require.GreaterOrEqual(t, result.ResultRuleIndex, 0)
			require.NotEmpty(t, result.ResultMessage.Text)
			require.NotEmpty(t, result.ResultLocations)

			// Validate only allowed properties exist
			expectedResultProperties := map[string]bool{
				"tags": true,
			}

			for propKey := range result.ResultProperties {
				require.True(t, expectedResultProperties[propKey],
					"Unexpected property in result for rule %s: %s", result.ResultRuleID, propKey)
			}

			// Validate tags property exists
			require.Contains(t, result.ResultProperties, "tags")

			// Validate result tags
			tags, ok := result.ResultProperties["tags"].([]string)
			require.True(t, ok, "Result tags should be []string")

			// Check for duplicates
			tagSet := make(map[string]bool)
			for _, tag := range tags {
				require.False(t, tagSet[tag], "Duplicate tag in result for rule %s: %s",
					result.ResultRuleID, tag)
				tagSet[tag] = true
			}

			// Validate only allowed tag prefixes
			for _, tag := range tags {
				hasAllowedPrefix := false
				for _, prefix := range allowedResultTagPrefixes {
					if strings.HasPrefix(tag, prefix) {
						hasAllowedPrefix = true
						break
					}
				}
				require.True(t, hasAllowedPrefix,
					"Unexpected tag in result for rule %s: %s", result.ResultRuleID, tag)
			}

			// Validate required tags are present
			hasResultTagPrefixes := make([]bool, len(requiredResultTagPrefixes))

			for _, tag := range tags {
				for idx, prefix := range requiredResultTagPrefixes {
					if strings.HasPrefix(tag, prefix) {
						hasResultTagPrefixes[idx] = true
						break
					}
				}
			}

			for idx, prefix := range requiredResultTagPrefixes {
				require.True(t, hasResultTagPrefixes[idx], fmt.Sprintf("Result for rule %s missing %s tag", result.ResultRuleID, prefix))
			}

			// Validate partial fingerprints
			require.NotEmpty(t, result.PartialFingerprints.DatadogFingerprint)
		}
	})

	t.Run("Rules and Results Correlation", func(t *testing.T) {
		rules := sarif.Runs[0].Tool.Driver.Rules
		results := sarif.Runs[0].Results

		// Build rule ID map
		ruleIDMap := make(map[string]int)
		for i, rule := range rules {
			ruleIDMap[rule.RuleID] = i
		}

		// Verify each result references a valid rule
		for _, result := range results {
			ruleIndex, exists := ruleIDMap[result.ResultRuleID]
			require.True(t, exists, "Result references unknown rule: %s", result.ResultRuleID)
			require.Equal(t, ruleIndex, result.ResultRuleIndex,
				"Result rule index mismatch for rule: %s", result.ResultRuleID)
		}
	})
}

// TestSarifOutputWithNoFindings validates that SARIF with no findings is valid
func TestSarifOutputWithNoFindings(t *testing.T) {
	ctx := context.Background()

	// Create empty SARIF report
	report := NewSarifReport()

	// Add tool tags
	now := time.Now()
	summary := &model.Summary{
		Times: model.Times{
			Start: now,
			End:   now.Add(10 * time.Second),
		},
		Counters: model.Counters{
			ScannedFiles: 10,
		},
	}
	err := report.AddTags(ctx, summary, &model.DiffAware{})
	require.NoError(t, err)

	// Cast to concrete type
	sarif := report.(*sarifReport)

	// Validate that empty rules and results are valid
	t.Run("Empty Rules and Results Are Valid", func(t *testing.T) {
		// There is always exactly one run, even when no findings
		require.Len(t, sarif.Runs, 1)

		rules := sarif.Runs[0].Tool.Driver.Rules
		results := sarif.Runs[0].Results

		// Empty arrays are valid for reports with no findings
		require.Empty(t, rules, "Rules should be empty when no findings")
		require.Empty(t, results, "Results should be empty when no findings")

		// Tool information should still be present
		driver := sarif.Runs[0].Tool.Driver
		require.Equal(t, expectedToolName, driver.ToolName)
		require.NotEmpty(t, driver.Properties.Tags)
	})
}
